<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robust Algorithm Complete Testing - QA Playground</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <style>
        .test-scenario {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            margin: 15px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-scenario h3 {
            margin-top: 0;
            color: #1976d2;
        }
        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #2196f3;
        }
        .warning-box {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #ffc107;
        }
        .success-box {
            background: #d4edda;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #28a745;
        }
        .element-box {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            border: 2px solid #ddd;
        }
        .grid-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .grid-3 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .attribute-list {
            font-family: monospace;
            font-size: 12px;
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .attribute-list div {
            padding: 3px 0;
        }
        .similar-element {
            background: #e8f5e9;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            border: 2px solid #4caf50;
        }
        .category-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            margin: 2px;
        }
        .cat1 { background: #4caf50; color: white; }
        .cat2 { background: #2196f3; color: white; }
    </style>
</head>
<body>
    <header>
        <div>
            <h1>Robust Algorithm Complete Testing</h1>
            <div class="small">Comprehensive test coverage for LCNC's robust element detection - All 18 scenarios from confluence docs</div>
        </div>
        <nav>
            <a href="../index.html">Home</a>
            <a href="robust-algorithm.html">Basic Version</a>
        </nav>
    </header>

    <main>
        <!-- Introduction -->
        <section class="card">
            <h2>üìã Complete Robust Algorithm Coverage</h2>
            <div class="info-box">
                <p><strong>This page includes ALL 18 test scenarios from the confluence documentation:</strong></p>
                <ul>
                    <li>10 Core scenarios (XPath, attributes, Shadow DOM, etc.)</li>
                    <li>8 Advanced scenarios (Category prioritization, form attributes, nested Shadow DOM, etc.)</li>
                </ul>
                <p><strong>Attribute Categories (from confluence):</strong></p>
                <div>
                    <span class="category-badge cat1">Category 1</span> Test Identity, Identity, Text, SVG, Trustable (name, href, src, aria-label)
                </div>
                <div>
                    <span class="category-badge cat2">Category 2</span> Form, Display, Aria, Data, Size attributes
                </div>
            </div>
        </section>

        <!-- Scenario 11: Attribute Category Prioritization -->
        <section class="card">
            <div class="test-scenario">
                <h3>üèÖ Scenario 11: Attribute Category Prioritization</h3>
                <p class="small">Test that Category 1 attributes are prioritized over Category 2 in scoring</p>
                
                <div class="warning-box">
                    <strong>Test:</strong> When multiple elements match, Category 1 attributes should score higher than Category 2
                </div>

                <div class="info-box">
                    <strong>Target Element (Record This):</strong>
                    <div>Category 1: data-testid, id, aria-label, name</div>
                    <div>Category 2: class, data-component</div>
                </div>

                <div class="similar-element">
                    <button 
                        id="cat-target"
                        data-testid="category-test"
                        aria-label="Submit Action"
                        name="submitButton"
                        class="btn primary"
                        data-component="button">
                        Target (4 Cat1 + 2 Cat2)
                    </button>
                </div>

                <div class="element-box">
                    <button 
                        id="cat-similar-1"
                        class="btn primary action-btn submit-btn"
                        data-component="button"
                        data-action="submit"
                        data-category="form">
                        Similar 1 (0 Cat1 + 5 Cat2)
                    </button>
                </div>

                <div class="element-box">
                    <button 
                        id="cat-similar-2"
                        data-testid="other-test"
                        aria-label="Cancel Action"
                        class="btn secondary"
                        data-component="button">
                        Similar 2 (2 Cat1 + 2 Cat2)
                    </button>
                </div>

                <div class="success-box">
                    <strong>Expected:</strong> Target should be selected because it has more Category 1 matches (4) than Similar 2 (2), even though Similar 1 has more total attributes
                </div>
            </div>
        </section>

        <!-- Scenario 12: Form Attributes Testing -->
        <section class="card">
            <div class="test-scenario">
                <h3>üìù Scenario 12: Form Attributes (Category 2)</h3>
                <p class="small">Test form attributes moved to Category 2: autocomplete, pattern, role, type, required, etc.</p>

                <div class="warning-box">
                    <strong>Test:</strong> Form attributes are now Category 2 (downgraded from trustable)
                </div>

                <div class="element-box">
                    <input 
                        type="email"
                        id="form-input"
                        data-testid="email-input"
                        autocomplete="email"
                        pattern="[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$"
                        required
                        role="textbox"
                        placeholder="Enter email"
                        maxlength="100"
                        minlength="5">
                </div>

                <button class="btn" onclick="modifyFormAttrs()">
                    Modify Form Attributes
                </button>

                <div class="attribute-list" id="form-attrs-display">
                    <strong>Form Attributes (Category 2):</strong>
                </div>

                <div class="info-box">
                    <strong>Form Attributes in Category 2:</strong> autocomplete, pattern, role, type, required, maxlength, minlength, form, formaction, formmethod, max, min, slot, autocapitalize, contenteditable
                </div>
            </div>
        </section>

        <!-- Scenario 13: aria-label as Trustable -->
        <section class="card">
            <div class="test-scenario">
                <h3>üéØ Scenario 13: aria-label as Trustable Attribute</h3>
                <p class="small">Test that aria-label is now in Category 1 (Trustable), not Category 2</p>

                <div class="warning-box">
                    <strong>Test:</strong> aria-label should be prioritized like other Category 1 attributes
                </div>

                <div class="element-box">
                    <button 
                        id="aria-btn-1"
                        aria-label="Primary Submit Button"
                        class="btn">
                        Button with aria-label (Cat1)
                    </button>

                    <button 
                        id="aria-btn-2"
                        aria-describedby="desc-1"
                        aria-controls="panel-1"
                        class="btn">
                        Button with other aria-* (Cat2)
                    </button>
                </div>

                <div class="info-box">
                    <strong>Category 1 (Trustable):</strong> aria-label<br>
                    <strong>Category 2 (Aria):</strong> All other aria-* attributes (aria-describedby, aria-controls, aria-expanded, etc.)
                </div>
            </div>
        </section>

        <!-- Scenario 14: Individual Class Matching -->
        <section class="card">
            <div class="test-scenario">
                <h3>üé® Scenario 14: Individual Class Matching (50% of classes)</h3>
                <p class="small">Test that class matching checks 50% of individual classes, not the whole attribute</p>

                <div class="warning-box">
                    <strong>Test:</strong> If ‚â•50% of recorded individual classes are present, class attribute matches
                </div>

                <div class="info-box">
                    <strong>Recorded Classes:</strong> btn primary-button action-button submit-button (4 classes)
                </div>

                <div class="element-box">
                    <button 
                        id="class-btn-1"
                        class="btn primary-button"
                        data-testid="class-test-1">
                        2/4 classes = 50% ‚úì Match
                    </button>

                    <button 
                        id="class-btn-2"
                        class="btn"
                        data-testid="class-test-2">
                        1/4 classes = 25% ‚úó No Match
                    </button>

                    <button 
                        id="class-btn-3"
                        class="btn primary-button action-button"
                        data-testid="class-test-3">
                        3/4 classes = 75% ‚úì Match
                    </button>
                </div>

                <button class="btn" onclick="testClassMatching()">
                    Test Class Matching
                </button>

                <div class="attribute-list" id="class-match-result">
                    <strong>Matching Results:</strong>
                </div>
            </div>
        </section>

        <!-- Scenario 15: Data Attribute Length Limits -->
        <section class="card">
            <div class="test-scenario">
                <h3>üìè Scenario 15: Data Attribute Length Limits</h3>
                <p class="small">Test that data-* attributes (except test identity) match only first 200 characters</p>

                <div class="warning-box">
                    <strong>Test:</strong> data-* attributes limited to 200 chars, text attributes to 100 chars
                </div>

                <div class="element-box">
                    <button 
                        id="length-btn"
                        data-testid="length-test"
                        data-description="This is a very long description that exceeds the 200 character limit for data attributes. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur."
                        title="This is a long title attribute that exceeds 100 characters for text attribute matching. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.">
                        Long Attributes Button
                    </button>
                </div>

                <button class="btn" onclick="analyzeAttributeLengths()">
                    Analyze Attribute Lengths
                </button>

                <div class="attribute-list" id="length-analysis">
                    <strong>Length Analysis:</strong>
                </div>

                <div class="info-box">
                    <strong>Limits:</strong><br>
                    ‚Ä¢ Text attributes (value, textContent, innerText, title, placeholder, alt, label): First 100 chars<br>
                    ‚Ä¢ Data attributes (data-*, except test identity): First 200 chars<br>
                    ‚Ä¢ Test identity attributes: Full match
                </div>
            </div>
        </section>

        <!-- Scenario 16: SVG Element innerHtml -->
        <section class="card">
            <div class="test-scenario">
                <h3>üé® Scenario 16: SVG Element innerHtml Handling</h3>
                <p class="small">Test that SVG elements use innerHTML as a Category 1 attribute</p>

                <div class="warning-box">
                    <strong>Test:</strong> For SVG elements, innerHTML is treated as a Category 1 attribute
                </div>

                <div class="element-box">
                    <svg id="svg-test" width="100" height="100" data-testid="svg-element">
                        <circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" />
                        <text x="50" y="55" text-anchor="middle" fill="black">SVG</text>
                    </svg>
                </div>

                <button class="btn" onclick="modifySVG()">
                    Modify SVG Content
                </button>

                <button class="btn" onclick="analyzeSVG()">
                    Analyze SVG Attributes
                </button>

                <div class="attribute-list" id="svg-analysis">
                    <strong>SVG Analysis:</strong>
                </div>

                <div class="info-box">
                    <strong>SVG Special Rule:</strong> innerHTML is Category 1 attribute for SVG elements only
                </div>
            </div>
        </section>

        <!-- Scenario 17: Elements with No Attributes -->
        <section class="card">
            <div class="test-scenario">
                <h3>üîç Scenario 17: Elements with No Attributes</h3>
                <p class="small">Test special handling when element has no attributes</p>

                <div class="warning-box">
                    <strong>Test:</strong> If element has no attributes, full xpath/css must match AND innerText must match
                </div>

                <div class="element-box">
                    <div style="padding: 10px; border: 1px solid #ddd;">
                        <button style="padding: 10px; background: #2196f3; color: white; border: none; border-radius: 4px;">
                            No Attributes Button
                        </button>
                    </div>
                </div>

                <div class="element-box">
                    <div style="padding: 10px; border: 1px solid #ddd;">
                        <span style="padding: 10px; display: inline-block;">
                            Plain Text Element
                        </span>
                    </div>
                </div>

                <div class="info-box">
                    <strong>Special Rules for No-Attribute Elements:</strong><br>
                    1. Full XPath or CSS path must match exactly<br>
                    2. If element has innerText, it must match<br>
                    3. For text validation/extract steps, check for text presence instead of exact match
                </div>
            </div>
        </section>

        <!-- Scenario 18: Nested Shadow DOM -->
        <section class="card">
            <div class="test-scenario">
                <h3>üåì Scenario 18: Nested Shadow DOM (Multiple Levels)</h3>
                <p class="small">Test element detection through multiple shadow host levels</p>

                <div class="warning-box">
                    <strong>Test:</strong> Algorithm should traverse multiple shadow root levels, calculating LCP from each shadow host
                </div>

                <div class="element-box">
                    <div id="nested-shadow-host-1" data-testid="outer-shadow">
                        <!-- Outer shadow root will be attached here -->
                    </div>
                </div>

                <button class="btn" onclick="createNestedShadowDOM()">
                    Create Nested Shadow DOM (3 levels)
                </button>

                <button class="btn" onclick="modifyNestedShadow()">
                    Modify Nested Shadow Content
                </button>

                <div class="attribute-list" id="nested-shadow-status">
                    <strong>Nested Shadow Status:</strong>
                    <div>Not created</div>
                </div>

                <div class="info-box">
                    <strong>Nested Shadow DOM Structure:</strong><br>
                    Level 1: Outer Shadow Host ‚Üí Shadow Root 1<br>
                    Level 2: Inner Shadow Host ‚Üí Shadow Root 2<br>
                    Level 3: Deepest Shadow Host ‚Üí Shadow Root 3<br>
                    Target: Button inside Shadow Root 3<br><br>
                    <strong>LCP Calculation:</strong> Calculated from each shadow host, not global root
                </div>
            </div>
        </section>

        <!-- Original 10 Scenarios (Collapsed for brevity - keeping structure) -->
        <section class="card">
            <h2>üìö Original 10 Core Scenarios</h2>
            <div class="info-box">
                <p>The original 10 scenarios are also available on this page. Scroll down or visit <a href="robust-algorithm.html">robust-algorithm.html</a> for the basic version.</p>
                <ul>
                    <li>Scenario 1: Attribute Value Changes</li>
                    <li>Scenario 2: XPath/Position Changes</li>
                    <li>Scenario 3: Dynamic Test Identity</li>
                    <li>Scenario 4: Multiple Similar Elements (50% Match)</li>
                    <li>Scenario 5: Obfuscated Class Names</li>
                    <li>Scenario 6: Text Attribute Matching</li>
                    <li>Scenario 7: Shadow DOM Elements</li>
                    <li>Scenario 8: Closest Reliable Parent (CRP)</li>
                    <li>Scenario 9: LCP Tiebreaker</li>
                    <li>Scenario 10: Volatile Attributes</li>
                </ul>
            </div>
        </section>
    </main>

    <script>
        // Scenario 12: Form Attributes
        function modifyFormAttrs() {
            const input = document.getElementById('form-input');
            input.setAttribute('autocomplete', 'off');
            input.setAttribute('pattern', '.+');
            input.removeAttribute('required');
            input.setAttribute('maxlength', '200');
            
            updateFormAttrsDisplay();
        }

        function updateFormAttrsDisplay() {
            const input = document.getElementById('form-input');
            const display = document.getElementById('form-attrs-display');
            const formAttrs = ['type', 'autocomplete', 'pattern', 'required', 'role', 'maxlength', 'minlength'];
            
            let html = '<strong>Form Attributes (Category 2):</strong>';
            formAttrs.forEach(attr => {
                const value = input.getAttribute(attr);
                if (value !== null) {
                    html += `<div>${attr}: ${value}</div>`;
                }
            });
            
            display.innerHTML = html;
        }

        // Scenario 14: Individual Class Matching
        function testClassMatching() {
            const recordedClasses = ['btn', 'primary-button', 'action-button', 'submit-button'];
            const buttons = [
                { id: 'class-btn-1', classes: ['btn', 'primary-button'] },
                { id: 'class-btn-2', classes: ['btn'] },
                { id: 'class-btn-3', classes: ['btn', 'primary-button', 'action-button'] }
            ];
            
            const display = document.getElementById('class-match-result');
            let html = '<strong>Matching Results:</strong>';
            
            buttons.forEach(btn => {
                const matchCount = btn.classes.filter(c => recordedClasses.includes(c)).length;
                const percentage = (matchCount / recordedClasses.length * 100).toFixed(0);
                const matches = percentage >= 50;
                
                html += `<div>${btn.id}: ${matchCount}/${recordedClasses.length} = ${percentage}% ${matches ? '‚úì Match' : '‚úó No Match'}</div>`;
            });
            
            display.innerHTML = html;
        }

        // Scenario 15: Attribute Length Limits
        function analyzeAttributeLengths() {
            const btn = document.getElementById('length-btn');
            const dataDesc = btn.getAttribute('data-description');
            const title = btn.getAttribute('title');
            
            const display = document.getElementById('length-analysis');
            display.innerHTML = `
                <strong>Length Analysis:</strong>
                <div>data-description: ${dataDesc.length} chars (limit: 200)</div>
                <div>First 200 chars: "${dataDesc.substring(0, 200)}..."</div>
                <div style="margin-top: 10px;">title: ${title.length} chars (limit: 100)</div>
                <div>First 100 chars: "${title.substring(0, 100)}..."</div>
                <div style="margin-top: 10px; color: #4caf50;"><strong>‚úì Algorithm will only match first 200/100 chars respectively</strong></div>
            `;
        }

        // Scenario 16: SVG Element
        function modifySVG() {
            const svg = document.getElementById('svg-test');
            svg.innerHTML = `
                <rect x="10" y="10" width="80" height="80" fill="blue" />
                <text x="50" y="55" text-anchor="middle" fill="white">MOD</text>
            `;
        }

        function analyzeSVG() {
            const svg = document.getElementById('svg-test');
            const display = document.getElementById('svg-analysis');
            
            display.innerHTML = `
                <strong>SVG Analysis:</strong>
                <div>Element Type: ${svg.tagName}</div>
                <div>innerHTML Length: ${svg.innerHTML.length} chars</div>
                <div>innerHTML (Category 1 for SVG): "${svg.innerHTML.substring(0, 100)}..."</div>
                <div style="margin-top: 10px; color: #4caf50;"><strong>‚úì innerHTML is treated as Category 1 attribute for SVG elements</strong></div>
            `;
        }

        // Scenario 18: Nested Shadow DOM
        function createNestedShadowDOM() {
            const host1 = document.getElementById('nested-shadow-host-1');
            
            if (!host1.shadowRoot) {
                // Level 1: Outer shadow root
                const shadow1 = host1.attachShadow({ mode: 'open' });
                shadow1.innerHTML = `
                    <style>
                        .shadow-container { padding: 20px; background: #e3f2fd; border-radius: 8px; }
                    </style>
                    <div class="shadow-container" data-testid="shadow-level-1">
                        <h4>Shadow Level 1</h4>
                        <div id="nested-shadow-host-2" data-testid="middle-shadow"></div>
                    </div>
                `;
                
                // Level 2: Middle shadow root
                const host2 = shadow1.getElementById('nested-shadow-host-2');
                const shadow2 = host2.attachShadow({ mode: 'open' });
                shadow2.innerHTML = `
                    <style>
                        .shadow-container { padding: 15px; background: #fff3cd; border-radius: 8px; }
                    </style>
                    <div class="shadow-container" data-testid="shadow-level-2">
                        <h5>Shadow Level 2</h5>
                        <div id="nested-shadow-host-3" data-testid="inner-shadow"></div>
                    </div>
                `;
                
                // Level 3: Deepest shadow root
                const host3 = shadow2.getElementById('nested-shadow-host-3');
                const shadow3 = host3.attachShadow({ mode: 'open' });
                shadow3.innerHTML = `
                    <style>
                        .shadow-container { padding: 10px; background: #d4edda; border-radius: 8px; }
                        .deep-btn { padding: 8px 16px; background: #673ab7; color: white; border: none; border-radius: 4px; cursor: pointer; }
                    </style>
                    <div class="shadow-container" data-testid="shadow-level-3">
                        <h6>Shadow Level 3</h6>
                        <button class="deep-btn" data-testid="deep-shadow-button">
                            Deep Shadow Button
                        </button>
                    </div>
                `;
                
                updateNestedShadowStatus('Created 3-level nested shadow DOM successfully');
            }
        }

        function modifyNestedShadow() {
            const host1 = document.getElementById('nested-shadow-host-1');
            
            if (host1.shadowRoot) {
                const host2 = host1.shadowRoot.getElementById('nested-shadow-host-2');
                if (host2 && host2.shadowRoot) {
                    const host3 = host2.shadowRoot.getElementById('nested-shadow-host-3');
                    if (host3 && host3.shadowRoot) {
                        const btn = host3.shadowRoot.querySelector('button');
                        btn.textContent = 'Modified Deep Button';
                        btn.className = 'deep-btn modified';
                        
                        updateNestedShadowStatus('Modified button in deepest shadow root (Level 3)');
                    }
                }
            } else {
                alert('Create nested shadow DOM first');
            }
        }

        function updateNestedShadowStatus(message) {
            const display = document.getElementById('nested-shadow-status');
            display.innerHTML = `
                <strong>Nested Shadow Status:</strong>
                <div>${message}</div>
                <div style="margin-top: 10px;">
                    <div>Level 1: Outer Shadow Host ‚Üí Shadow Root 1</div>
                    <div>Level 2: Middle Shadow Host ‚Üí Shadow Root 2</div>
                    <div>Level 3: Deepest Shadow Host ‚Üí Shadow Root 3</div>
                    <div style="color: #4caf50; margin-top: 5px;"><strong>‚úì LCP calculated from each shadow host</strong></div>
                </div>
            `;
        }

        // Initialize displays on page load
        window.addEventListener('DOMContentLoaded', function() {
            updateFormAttrsDisplay();
            testClassMatching();
            analyzeAttributeLengths();
            analyzeSVG();
        });
    </script>
</body>
</html>